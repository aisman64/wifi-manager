#!/usr/bin/python

import gobject
import dbus
import dbus.service
import dbus.mainloop.glib
import os
import io
import sys
import time
import json
import subprocess
from threading import Thread

try:
    from gi.repository import GObject
except ImportError:
    import gobject as GObject

SERVICE_HISTORY_PATH = "/etc/wifi_manager/services.json"

class Canceled(dbus.DBusException):
	_dbus_error_name = "net.connman.Error.Canceled"

class LaunchBrowser(dbus.DBusException):
	_dbus_error_name = "net.connman.Agent.Error.LaunchBrowser"

class Agent(dbus.service.Object):
	name = None
	ssid = None
	identity = None
	passphrase = None
	wpspin = None
	username = None
	password = None

	def input_passphrase(self):
		response = {}

		if not self.identity and not self.passphrase and not self.wpspin:
			print "Service credentials requested, type cancel to cancel"
			args = raw_input('Answer: ')

			for arg in args.split():
				if arg.startswith("cancel"):
					response["Error"] = arg
				if arg.startswith("Identity="):
					identity = arg.replace("Identity=", "", 1)
					response["Identity"] = identity
				if arg.startswith("Passphrase="):
					passphrase = arg.replace("Passphrase=", "", 1)
					response["Passphrase"] = passphrase
				if arg.startswith("WPS="):
					wpspin = arg.replace("WPS=", "", 1)
					response["WPS"] = wpspin
					break
		else:
			if self.identity:
				response["Identity"] = self.identity
			if self.passphrase:
				response["Passphrase"] = self.passphrase
			if self.wpspin:
				response["WPS"] = self.wpspin

		return response

	def input_username(self):
		response = {}

		if not self.username and not self.password:
			print "User login requested, type cancel to cancel"
			print "or browser to login through the browser by yourself."
			args = raw_input('Answer: ')

			for arg in args.split():
				if arg.startswith("cancel") or arg.startswith("browser"):
					response["Error"] = arg
				if arg.startswith("Username="):
					username = arg.replace("Username=", "", 1)
					response["Username"] = username
				if arg.startswith("Password="):
					password = arg.replace("Password=", "", 1)
					response["Password"] = password
		else:
			if self.username:
				response["Username"] = self.username
			if self.password:
				response["Password"] = self.password

		return response

	def input_hidden(self):
		response = {}

		if not self.name and not self.ssid:
			args = raw_input('Answer ')

			for arg in args.split():
				if arg.startswith("Name="):
					name = arg.replace("Name=", "", 1)
					response["Name"] = name
					break
				if arg.startswith("SSID="):
					ssid = arg.replace("SSID", "", 1)
					response["SSID"] = ssid
					break
		else:
			if self.name:
				response["Name"] = self.name
			if self.ssid:
				response["SSID"] = self.ssid

		return response

	@dbus.service.method("net.connman.Agent",
					in_signature='oa{sv}',
					out_signature='a{sv}')
	def RequestInput(self, path, fields):
		print "RequestInput (%s,%s)" % (path, fields)

		response = {}

		if fields.has_key("Name"):
			response.update(self.input_hidden())
		if fields.has_key("Passphrase"):
			response.update(self.input_passphrase())
		if fields.has_key("Username"):
			response.update(self.input_username())

		if response.has_key("Error"):
			if response["Error"] == "cancel":
				raise Canceled("canceled")
				return
			if response["Error"] == "browser":
				raise LaunchBrowser("launch browser")
				return

		print "returning (%s)" % (response)

		return response

	@dbus.service.method("net.connman.Agent",
					in_signature='os',
					out_signature='')
	def RequestBrowser(self, path, url):
		print "RequestBrowser (%s,%s)" % (path, url)

		print "Please login through the given url in a browser"
		print "Then press enter to accept or some text to cancel"

		args = raw_input('> ')

		if len(args) > 0:
			raise Canceled("canceled")

		return

	@dbus.service.method("net.connman.Agent",
					in_signature='os',
					out_signature='')
	def ReportError(self, path, error):
		print "ReportError %s, %s" % (path, error)
		retry = raw_input("Retry service (yes/no): ")
		if (retry == "yes"):
			class Retry(dbus.DBusException):
				_dbus_error_name = "net.connman.Agent.Error.Retry"

			raise Retry("retry service")
		else:
			return


	@dbus.service.method("net.connman.Agent",
					in_signature='', out_signature='')
	def Cancel(self):
		print "Cancel"

def get_machine_id():
    id_file = open('/etc/machine-id', 'r')
    machine_id = id_file.readline()
    id_file.close()
    return machine_id.upper()

def check_wifi():
	for path,properties in manager.GetTechnologies():
		if properties["Type"] == "wifi":
			technology = dbus.Interface(bus.get_object("net.connman", path), "net.connman.Technology")

			# Enable WiFi
			if properties["Powered"] == dbus.Boolean(0):
				technology.SetProperty("Powered", dbus.Boolean(1))
				time.sleep(2)
			
			return True
	return False

# Parses services to ensure they are suitable for JSON encoding
def parse_services(services):
	for path,properties in services:
		properties["Strength"] = int(properties["Strength"])

	return services

def scan_services():
	for path,properties in manager.GetTechnologies():
		if properties["Type"] == "wifi":
			technology = dbus.Interface(bus.get_object("net.connman", path), "net.connman.Technology")
			
			# Scan for services
			technology.Scan(timeout=20000)

			# Retrieve services
			services = manager.GetServices()

			# Save to history
			with open(SERVICE_HISTORY_PATH, 'w') as f:
  				json.dump(parse_services(services), f, skipkeys=True)
				f.close()


def get_services():
	scan_services()
	# Get services from history if tethering is enabled
	if is_tethering_enabled():
		if os.path.isfile(SERVICE_HISTORY_PATH):
			with open(SERVICE_HISTORY_PATH) as f:
				services = json.load(f)
				f.close() 
    				return services
	
	# Scan WiFi services and return as normal	
	else:
		scan_services()
		return manager.GetServices()

	return None


def check_service(service):
	# Check service exists
	services = get_services()
	for path,properties in services:
		if service in path:
			return True

	return False

def connect_service(path):
	try:
		service = dbus.Interface(bus.get_object("net.connman", path),
						"net.connman.Service")
		time.sleep(2)

		# Attempt to connect service
		service.Connect(timeout=60000)
		print "\n Connected"
		mainloop.quit()
		return
	except dbus.DBusException, error:
		print "%s: %s" % (error._dbus_error_name, error.message)
		mainloop.quit()
		return

def print_services(services):
	for path, properties in services:
		identifier = path[path.rfind("/") + 1:]
		state = " "
		autoconnect = "  "

		if properties["Favorite"] == dbus.Boolean(1):
			favorite = "*"

			if properties["AutoConnect"] == dbus.Boolean(1):
				autoconnect = " A"
			else:
				autoconnect = "  "

			if properties["State"] == "ready":
				state = "R"
			elif properties["State"] == "online":
				state = "O"
		else:
			favorite = " "

		if "Name" in properties.keys():
			name = properties["Name"]
		else:
			name = "{" + properties["Type"] + "}"

		print "%s%s%s %-26s %s" % (favorite, autoconnect, state,
					       name, identifier)

def is_tethering_enabled():
	for path,properties in manager.GetTechnologies():
		if properties["Type"] == "wifi":
			if properties["Tethering"] == dbus.Boolean(1):
				return True
	return False

def toggle_tethering():
    	if is_tethering_enabled():
		disable_tethering()
    	else:
		enable_tethering()

def enable_tethering():
    	# Check tethering is not already enabled
	if is_tethering_enabled():
		print "Tethering is already enabled!"
		return

	# Save WiFi services to history
	scan_services()
	
    	# Check for override script and use if available to enable tethering (required for Edison)
    	if os.path.isfile("/usr/bin/wifi-tethering"):
		subprocess.call("/usr/bin/wifi-tethering enable", shell=True)
		return

	# Enable tethering normally
	technologies = manager.GetTechnologies()
	for (path, properties) in technologies:
	    if properties["Type"] == "wifi":
		technology = dbus.Interface(bus.get_object("net.connman", path),
					"net.connman.Technology")

		print "\n Enabling WiFi tethering...\n"

		# Check SSID is set
		if not "TetheringIdentifier" in properties:
		    ssid = "IoT-Device-" + get_machine_id()
	            technology.SetProperty("TetheringIdentifier", ssid)

		# Check password is set
		if not "TetheringPassphrase" in properties:
		    technology.SetProperty("TetheringPassphrase", "password")

		# Enable tethering
		technology.SetProperty("Tethering", dbus.Boolean(1))

    		print "Success"

def disable_tethering():
    	# Check for override script and use if available to enable tethering (required for Edison)
    	if os.path.isfile("/usr/bin/wifi-tethering"):
		subprocess.call("/usr/bin/wifi-tethering disable", shell=True)
		return

	# Disable tethering normally
	technologies = manager.GetTechnologies()

	for (path, properties) in technologies:
	    if properties["Type"] == "wifi":
		technology = dbus.Interface(bus.get_object("net.connman", path),
						"net.connman.Technology")

		# Disable tethering
		if properties["Tethering"] == dbus.Boolean(1):
		    print "\n Disabling WiFi tethering...\n"
		    technology.SetProperty("Tethering", dbus.Boolean(0))
		else:
		    print "Tethering already disabled!"
		    return

def print_usage():
	print "\nUsage:"
	print "For hidden service:"
	print "%s Name=<hidden service name> [SSID=<hidden ssid>]" % (sys.argv[0])
	print "For EAP/WPA input:"
	print "%s Identity=<identity> Passphrase=<passphrase> WPS=<wpspin>" % (sys.argv[0])
	print "For WISPr login, L2TP or PPTP input:"
	print "%s Username=<username> Password=<password>" % (sys.argv[0])
	print "For OpenConnect input:"
	print "%s Cookie=<string>" % (sys.argv[0])
	print "Help: %s help" % (sys.argv[0])
	sys.exit(1)

if __name__ == '__main__':
	if len(sys.argv) == 2 and sys.argv[1] == "help":
		print_usage()

	if (len(sys.argv) < 2):
		print "Please specify a command to perform!"
		print_usage()

	try:
		# Setup Connman DBus connection
		dbus.mainloop.glib.DBusGMainLoop(set_as_default=True)
		bus = dbus.SystemBus()
		manager = dbus.Interface(bus.get_object('net.connman', "/"),
					'net.connman.Manager')
		
		# Check WiFi
		if not check_wifi():
			print "Error: WiFi not found on this device!"
			sys.exit(1)

		#
		# Connect
		#

		if sys.argv[1] == "connect":
			# Check service argument
			if (len(sys.argv) < 3):
				print "Error: No service specified!"
				print_usage()

			# Check WiFi service exists
			if not check_service(sys.argv[2]):
				print "Error: Service doesn't exist!"
				sys.exit(1)

			# Register and populate agent
			object = Agent(bus, "/wifi_manager/agent")

			if len(sys.argv) > 3:
				for arg in sys.argv[3:]:
					if arg.startswith("Name="):
						object.name = arg.replace("Name=", "", 1)
					elif arg.startswith("SSID="):
						object.ssid = arg.replace("SSID=", "", 1)
					elif arg.startswith("Identity="):
						object.identity = arg.replace("Identity=", "", 1)
					elif arg.startswith("Passphrase="):
						object.passphrase = arg.replace("Passphrase=", "", 1)
					elif arg.startswith("WPS="):
						object.wpspin = arg.replace("WPS=", "", 1)

			manager.RegisterAgent("/wifi_manager/agent")
		
			# Start service connection thread
			Thread(target=connect_service, args=("/net/connman/service/" + sys.argv[2],)).start()

			# Start agent thread
			GObject.threads_init()
			mainloop = gobject.MainLoop()
			mainloop.run()

		#
		# Services
		#

		elif sys.argv[1] == "services":

			# Scan for WiFi services and print them on the console
			print_services(get_services())

		#
		# Tethering
		#
		
		elif sys.argv[1] == "tether":

			# Check arguments
			if (len(sys.argv) < 3):
				print "Error: No command specified!"
				print_usage()

			# Parse arguments
			if sys.argv[2] == "enable":
				enable_tethering()
			elif sys.argv[2] == "disable":
				disable_tethering()
			elif sys.argv[2] == "toggle":
				toggle_tethering()
			else:
				print "Error: Command not recognised!"
				print_usage()

		else:
			print "Error: Command not recognised!"
			print_usage()

	except dbus.DBusException, error:
		print "Unable to connect to Connman service!"
		sys.exit()

