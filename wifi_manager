#!/usr/bin/python

#
# Written by Scott Ware
#
# Version 0.0.2
#

import gobject
import dbus
import dbus.service
import dbus.mainloop.glib
import os
import io
import sys
import time
import json
import subprocess
import string
import random
from threading import Thread

try:
    from gi.repository import GObject
except ImportError:
    import gobject as GObject

SERVICE_HISTORY_PATH = "/etc/wifi_manager/services.json"

class Canceled(dbus.DBusException):
	_dbus_error_name = "net.connman.Error.Canceled"

class LaunchBrowser(dbus.DBusException):
	_dbus_error_name = "net.connman.Agent.Error.LaunchBrowser"

class Agent(dbus.service.Object):
	name = None
	identity = None
	passphrase = None
	wpspin = None
	username = None
	password = None

	@dbus.service.method("net.connman.Agent",
					in_signature='', out_signature='')
	def Release(self):
		print("Agent Released!")
		mainloop.quit()

	def get_identity(self):
		response = {}

		if not self.identity:
			while 1:
				identity = raw_input("Please enter identity: ")

				if (len(identity) > 0):
					response["Identity"] = identity
					break
				else:
					print "\n** Nothing entered. Please try again. **"
		else:
			response["Identity"] = self.identity

		return response

	def get_passphrase(self):
		response = {}

		if not self.passphrase and not self.wpspin:
			while 1:
				passphrase = raw_input("Please enter passphrase: ")

				if (len(passphrase) < 8):
					print "\n** Passphrase must be longer than 8 characters. Please try again. **"
				else:
					response["Passphrase"] = passphrase
					break
		else:
			if self.passphrase:
				response["Passphrase"] = self.passphrase
			if self.wpspin:
				response["WPS"] = self.wpspin

		return response

	def get_username(self):
		response = {}

		if not self.username:
			while 1:
				username = raw_input("Please enter username: ")

				if (len(username) > 0):
					response["Username"] = username
					break
				else:
					print "\n** Nothing entered. Please try again. **"
		else:
			response["Username"] = self.username

		return response

	def get_password(self):
		response = {}

		if not self.password:
			while 1:
				password = raw_input("Please enter password: ")

				if (len(password) > 0):
					response["Password"] = password
					break
				else:
					print "\n** Nothing entered. Please try again. **"
		else:
			response["Password"] = self.password

		return response

	def get_name(self):
		response = {}

		if not self.name:
			while 1:
				name = raw_input("Please enter service name: ")

				if (len(name) > 0):
					response["Name"] = name
					break
				else:
					print "\n** Nothing entered. Please try again. **"
		else:
			response["Name"] = self.name

		return response

	@dbus.service.method("net.connman.Agent",
					in_signature='oa{sv}',
					out_signature='a{sv}')
	def RequestInput(self, path, fields):
		# print "RequestInput (%s,%s)" % (path, fields)

		response = {}

		if fields.has_key("Name"):
			response.update(self.get_name())
		if fields.has_key("Identity"):
			response.update(self.get_identity())
		if fields.has_key("Passphrase"):
			response.update(self.get_passphrase())
		if fields.has_key("Username"):
			response.update(self.get_username())
		if fields.has_key("Password"):
			response.update(self.get_password())

		if response.has_key("Error"):
			if response["Error"] == "cancel":
				raise Canceled("canceled")
				return
			if response["Error"] == "browser":
				raise LaunchBrowser("launch browser")
				return

		# print "returning (%s)" % (response)

		return response

	@dbus.service.method("net.connman.Agent",
					in_signature='os',
					out_signature='')
	def ReportError(self, path, error):
		print "ReportError %s, %s" % (path, error)
		retry = raw_input("Retry service (yes/no): ")
		if (retry == "yes"):
			class Retry(dbus.DBusException):
				_dbus_error_name = "net.connman.Agent.Error.Retry"

			raise Retry("retry service")
		else:
			return

	@dbus.service.method("net.connman.Agent",
					in_signature='os',
					out_signature='')
	def ReportPeerError(self, path, error):
		print "ReportError %s, %s" % (path, error)
		retry = raw_input("Retry service (yes/no): ")
		if (retry == "yes"):
			class Retry(dbus.DBusException):
				_dbus_error_name = "net.connman.Agent.Error.Retry"

			raise Retry("retry service")
		else:
			return


	@dbus.service.method("net.connman.Agent",
					in_signature='', out_signature='')
	def Cancel(self):
		print "Cancel"

def id_generator(size=6, chars=string.ascii_uppercase + string.digits):
	return ''.join(random.choice(chars) for _ in range(size))

def get_machine_id():
    	id_file = open('/etc/machine-id', 'r')
    	machine_id = id_file.readline().strip().upper()
    	id_file.close()
    	return machine_id

def get_hostname():
    	name_file = open('/etc/hostname', 'r')
    	hostname = name_file.readline().strip()
    	name_file.close()
	hostname.replace(" ", "_")
    	return hostname

def get_platform():
    	platform_file = open('/sys/class/dmi/id/board_name', 'r')
    	platform = platform_file.readline()
    	platform_file.close()
	
	if platform in ['BODEGA BAY\n', 'SALT BAY\n']:
    		return "edison"

    	return None

def check_wifi():
	for path,properties in manager.GetTechnologies():
		if properties["Type"] == "wifi":
			technology = dbus.Interface(bus.get_object("net.connman", path), "net.connman.Technology")

			# Enable WiFi
			if properties["Powered"] == dbus.Boolean(0):
				technology.SetProperty("Powered", dbus.Boolean(1))
				time.sleep(2)
			
			return True
	return False

# Parses services to ensure they are suitable for JSON encoding
def parse_services(services):
	for path,properties in services:
		properties["Strength"] = int(properties["Strength"])

	return services

def scan_services():
	for path,properties in manager.GetTechnologies():
		if properties["Type"] == "wifi":
			technology = dbus.Interface(bus.get_object("net.connman", path), "net.connman.Technology")
			
			# Scan for services
			technology.Scan(timeout=20)

			# Retrieve services
			services = manager.GetServices(timeout=20)

			# Save to history
			with open(SERVICE_HISTORY_PATH, 'w') as f:
  				json.dump(parse_services(services), f, skipkeys=True)
				f.close()


def get_services():
	# Get services from history if tethering is enabled
	if is_tethering_enabled():
		if os.path.isfile(SERVICE_HISTORY_PATH):
			with open(SERVICE_HISTORY_PATH) as f:
				services = json.load(f)
				f.close() 
    				return services
	
	# Scan WiFi services and return as normal	
	else:
		scan_services()
		return manager.GetServices(timeout=20)

	return None


def check_service(service):
	# Check service exists
	services = get_services()
	for path,properties in services:
		if service in path:
			return True

	return False

def connect_service(path):
	try:
		service = dbus.Interface(bus.get_object("net.connman", path),
						"net.connman.Service")
		time.sleep(2)

		# Attempt to connect service
		os.system('clear')
		print "Attempting connection to service..."
		service.Connect(timeout=60000)
		print "\n Connected"
		mainloop.quit()
		return
	except dbus.DBusException, error:
		if error.get_dbus_name() in ['net.connman.Error.AlreadyConnected']:
			print "This service is already connected!"
		elif error.get_dbus_name() in ['net.connman.Error.InProgress']:
			print "This service is in the process of connecting. Please try again later if not connected shortly."
		elif error.get_dbus_name() in ['net.connman.Error.OperationAborted']:
			print "Unable to connect at this time. Please try again later."
		elif error.get_dbus_name() in ['net.connman.Error.InvalidArguments']:
			print "Unable to connect to the service with the details provided. Please try again."
		else:
			print "%s: %s" % (error._dbus_error_name, error.message)

		mainloop.quit()
		return

def print_services(services):
	os.system('clear')
	print "\nWiFi Services\n=============\n"
	for path, properties in services:
		identifier = path[path.rfind("/") + 1:]
		state = " "
		autoconnect = "  "

		if properties["Favorite"] == dbus.Boolean(1):
			favorite = "*"

			if properties["AutoConnect"] == dbus.Boolean(1):
				autoconnect = " A"
			else:
				autoconnect = "  "
		else:
			favorite = " "

		if "Name" in properties.keys():
			name = properties["Name"]
		else:
			name = "{" + properties["Type"] + "}"

		print "%s%s %-26s %s" % (favorite, autoconnect, name, identifier)

def is_tethering_enabled():
	for path,properties in manager.GetTechnologies():
		if properties["Type"] == "wifi":
			if properties["Tethering"] == dbus.Boolean(1):
				return True
	return False

def toggle_tethering():
    	if is_tethering_enabled():
		disable_tethering()
    	else:
		enable_tethering()

def enable_tethering():
    	# Check tethering is not already enabled
	if is_tethering_enabled():
		print "Tethering is already enabled!"
		return

	# Save WiFi services to history
	scan_services()

	technologies = manager.GetTechnologies()
	for (path, properties) in technologies:
	    	if properties["Type"] == "wifi":
			technology = dbus.Interface(bus.get_object("net.connman", path),
						"net.connman.Technology")

			print "\n Enabling WiFi tethering...\n"

			# Check SSID is set
			if not "TetheringIdentifier" in properties:
		    		ssid = get_hostname() + get_machine_id()
	            		technology.SetProperty("TetheringIdentifier", ssid[:32])

			# Check password is set
			if not "TetheringPassphrase" in properties:
		    		technology.SetProperty("TetheringPassphrase", "password")

			# Edison
			if get_platform() is "edison":
				# Reload WiFi driver in AP mode
				result = subprocess.call("modprobe -r bcm4334x", shell=True)
				if(result != 0):
					print "Error: Unable to remove WiFi module."
					return False

				time.sleep(1)

				result = subprocess.call("modprobe bcm4334x op_mode=2", shell=True)
				if(result != 0):
					print "Error: Unable to load WiFi module in AP mode."
					return False

				time.sleep(2)

				subprocess.call("rfkill unblock wlan", shell=True)

				# Check WiFi is ready
				if not check_wifi():
					print "Error: Unable to re-initialise WiFi module."
					return False

			# Enable tethering
			technology.SetProperty("Tethering", dbus.Boolean(1))

			# Edison Fix
			if get_platform() is "edison":
				time.sleep(2)

				# FIXME: ConnMan will try to add wlan0 to tether bridge but in Edison
				# that currently fails with EBUSY.
				result = subprocess.call("brctl addif tether wlan0", shell=True)
				if(result != 0):
					print "Error: Unable to bridge wireless interface."
					return False

    			print "Success"
			return True

def disable_tethering():

	technologies = manager.GetTechnologies()

	for (path, properties) in technologies:
	    	if properties["Type"] == "wifi":
			technology = dbus.Interface(bus.get_object("net.connman", path),
							"net.connman.Technology")

			# Disable tethering
			if properties["Tethering"] == dbus.Boolean(1):
		    		print "\n Disabling WiFi tethering...\n"
		    		technology.SetProperty("Tethering", dbus.Boolean(0))
			
				# Edison
				if get_platform() is "edison":
					# Reload WiFi driver in normal mode
					result = subprocess.call("modprobe -r bcm4334x", shell=True)
					if(result != 0):
						print "Error: Unable to remove WiFi module."
						return False

					time.sleep(1)

					result = subprocess.call("modprobe bcm4334x", shell=True)
					if(result != 0):
						print "Error: Unable to load WiFi module."
						return False
					
					time.sleep(2)

					subprocess.call("rfkill unblock wlan", shell=True)

					# Check WiFi is ready
					if not check_wifi():
						print "Error: Unable to re-initialise WiFi module."
						return False
			else:
		    		print "Tethering already disabled!"
		    		
			return True

def print_usage():
	print "\nUsage:\n"
	print "wifi_manager services: List available WiFi services."
	print "\nwifi_manager connect [SERVICE_NAME]: Initialise connection to WiFi service."
	print "\nFor EAP/WPA:"
	print "wifi_manager connect [SERVICE_NAME] [Passphrase=<passphrase>]"
	print "\nFor WISPr login, L2TP or PPTP:"
	print "wifi_manager connect [SERVICE_NAME] [Username=<username>] [Password=<password>]"
	print "\nwifi_manager tether [enable|disable|toggle]: Enable, disable or toggle WiFi tethering (AP Mode)."
	print "\nwifi_manager help: Prints this usage guide.\n"
	sys.exit(1)

if __name__ == '__main__':
	if len(sys.argv) == 2 and sys.argv[1] == "help":
		print_usage()

	if (len(sys.argv) < 2):
		print "Please specify a command to perform!"
		print_usage()

	try:
		# Setup Connman DBus connection
		dbus.mainloop.glib.DBusGMainLoop(set_as_default=True)
		bus = dbus.SystemBus()
		manager = dbus.Interface(bus.get_object('net.connman', "/"),
					'net.connman.Manager')
		
		# Check WiFi
		if not check_wifi():
			print "Error: WiFi not found on this device!"
			sys.exit(1)

		#
		# Connect
		#

		if sys.argv[1] == "connect":
			# Check service argument
			if (len(sys.argv) < 3):
				print "Error: No service specified!"
				print_usage()

			# Make sure tethering is disabled
			if is_tethering_enabled():
				if not disable_tethering():
					sys.exit(1)

			# Check WiFi service exists
			if not check_service(sys.argv[2]):
				print "Error: Service doesn't exist!"
				sys.exit(1)

			# Register and populate agent
			agent_id = "/wifi_manager/agent" + id_generator()
			object = Agent(bus, agent_id)
			object.name = sys.argv[2]

			if len(sys.argv) > 3:
				for arg in sys.argv[3:]:
					if arg.startswith("Identity="):
						object.identity = arg.replace("Identity=", "", 1)
					elif arg.startswith("Passphrase="):
						object.passphrase = arg.replace("Passphrase=", "", 1)
					elif arg.startswith("WPS="):
						object.wpspin = arg.replace("WPS=", "", 1)
					elif arg.startswith("Username="):
						object.username = arg.replace("Username=", "", 1)
					elif arg.startswith("Password="):
						object.password = arg.replace("Password=", "", 1)

			manager.RegisterAgent(agent_id)
		
			# Start service connection thread
			Thread(target=connect_service, args=("/net/connman/service/" + sys.argv[2],)).start()

			# Start agent thread
			GObject.threads_init()
			mainloop = gobject.MainLoop()
			mainloop.run()

		#
		# Services
		#

		elif sys.argv[1] == "services":

			# Scan for WiFi services and print them on the console
			print_services(get_services())

		#
		# Tethering
		#
		
		elif sys.argv[1] == "tether":

			# Check arguments
			if (len(sys.argv) < 3):
				print "Error: No command specified!"
				print_usage()

			# Parse arguments
			if sys.argv[2] == "enable":
				enable_tethering()
			elif sys.argv[2] == "disable":
				disable_tethering()
			elif sys.argv[2] == "toggle":
				toggle_tethering()
			else:
				print "Error: Command not recognised!"
				print_usage()

		else:
			print "Error: Command not recognised!"
			print_usage()

	except dbus.DBusException, error:
		if error.get_dbus_name() in ['net.connman.Error.ServiceUnknown']:
			print "Error: Connman service is not currently running. Please enable Connman before using WiFi Manager!"
		else:
			print "%s: %s" % (error._dbus_error_name, error.message)
		sys.exit()

